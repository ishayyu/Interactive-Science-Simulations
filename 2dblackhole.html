<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Black Hole Gravity Simulation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: black;
            color: white;
            font-family: Arial, sans-serif;
        }

        canvas {
            display: block;
        }

        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 8px;
        }

            .controls label {
                font-size: 14px;
                display: block;
                margin: 5px 0;
            }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="controls">
        <label>Speed: <input id="speedSlider" type="range" min="0.1" max="3" step="0.1" value="1"></label>
        <label>Gravity: <input id="gravitySlider" type="range" min="1000" max="20000" step="500" value="10000"></label>
        <div id="particleCount">Particles: 0</div>
    </div>
    <script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const center = { x: canvas.width / 2, y: canvas.height / 2 };
const particles = [];
let G = 10000;
const BH_RADIUS = 30;
const EVENT_HORIZON = 90;
const PARTICLE_LIFETIME = 12000;
let speedFactor = 1;

// --- NEW: particle limit ---
const MAX_PARTICLES = 1000;

// sliders
const speedSlider = document.getElementById("speedSlider");
const gravitySlider = document.getElementById("gravitySlider");
const particleCount = document.getElementById("particleCount");
speedSlider.oninput = () => { speedFactor = parseFloat(speedSlider.value); };
gravitySlider.oninput = () => { G = parseFloat(gravitySlider.value); };

// background stars
const stars = [];
for (let i = 0; i < 100; i++) {
            stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 2,
                twinkle: Math.random() * 0.1
            });
}
function drawStars() {
            ctx.fillStyle = "white";
            stars.forEach(star => {
                star.size += (Math.random() - 0.5) * star.twinkle;
                star.size = Math.max(0.5, Math.min(2, star.size));
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
}

// particles
function randomParticle() {
            const angle = Math.random() * Math.PI * 2;
            const r = 200 + Math.random() * 300;
            const x = center.x + Math.cos(angle) * r;
            const y = center.y + Math.sin(angle) * r;
            return {
                x, y,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                color: `hsl(${Math.random() * 360}, 80%, 70%)`,
                birthTime: Date.now()
            };
}

// initial particles (reduced from 400 → 20)
for (let i = 0; i < 20; i++) {
            particles.push(randomParticle());
}

// click spawn
canvas.addEventListener('click', e => {
            for (let i = 0; i < 5; i++) {
                if (particles.length < MAX_PARTICLES) {
                    particles.push({
                        x: e.clientX, y: e.clientY,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        color: `hsl(${Math.random() * 360}, 80%, 70%)`,
                        birthTime: Date.now()
                    });
                }
            }
});

// explosion
function explosion(x, y, color) {
            for (let i = 0; i < 3; i++) { // smaller burst
                if (particles.length < MAX_PARTICLES) {
                    particles.push({
                        x, y,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        color,
                        birthTime: Date.now()
                    });
                }
            }
}

// update loop
function update() {
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    drawStars();

    const now = Date.now();
    let totalDist = 0;
    let totalVel = 0;
    let maxForce = 0;

    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        if (now - p.birthTime > PARTICLE_LIFETIME) {
            particles.splice(i, 1);
            continue;
        }

        const dx = center.x - p.x;
        const dy = center.y - p.y;
        const dist2 = dx * dx + dy * dy;
        const dist = Math.sqrt(dist2);

        // accumulate distance + velocity for averages
        totalDist += dist;
        totalVel += Math.sqrt(p.vx * p.vx + p.vy * p.vy);

        // track strongest gravitational force
        const forceNow = G / (dist2 / 4);
        if (forceNow > maxForce) maxForce = forceNow;

        if (dist < BH_RADIUS) {
            explosion(p.x, p.y, p.color);
            particles.splice(i, 1);
            continue;
        }

        const force = forceNow;
        const ax = (dx / dist) * force * 1.5;
        const ay = (dy / dist) * force * 1.5;

        p.vx += ax * 0.025 * speedFactor;
        p.vy += ay * 0.025 * speedFactor;
        p.x += p.vx * speedFactor;
        p.y += p.vy * speedFactor;

        ctx.shadowBlur = 8;
        ctx.shadowColor = p.color;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
        ctx.fill();
    }

    // black hole center
    ctx.shadowBlur = 40;
    ctx.shadowColor = "white";
    ctx.fillStyle = "black";
    ctx.beginPath();
    ctx.arc(center.x, center.y, BH_RADIUS, 0, Math.PI * 2);
    ctx.fill();

    // event horizon
    ctx.shadowBlur = 0;
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(center.x, center.y, EVENT_HORIZON, 0, Math.PI * 2);
    ctx.stroke();

    // === DISPLAY CALCULATIONS ===
    const avgDist = (particles.length > 0) ? (totalDist / particles.length).toFixed(1) : 0;
    const avgVel = (particles.length > 0) ? (totalVel / particles.length).toFixed(2) : 0;
    const BH_mass_est = (G / 1000).toFixed(0); // fake estimate for display

    ctx.shadowBlur = 0;
    ctx.fillStyle = "white";
    ctx.font = "16px Arial";
    ctx.textAlign = "left";
    ctx.fillText("Particles: " + particles.length, 1000, 40);
    ctx.fillText("Avg Distance: " + avgDist, 1000, 60);
    ctx.fillText("Avg Velocity: " + avgVel, 1000, 80);
    ctx.fillText("Max Gravity Force: " + maxForce.toFixed(2), 1000, 100);
    ctx.fillText("BH Mass Estimate: " + BH_mass_est, 1000, 120);

    // instructions
    ctx.textAlign = "center";
    ctx.fillText("Click anywhere to spawn particles", canvas.width / 2, 40);

    requestAnimationFrame(update);
}

update();
    </script>
</body>
</html>
